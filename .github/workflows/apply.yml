name: Deploy Vertica DB (apply)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      recreate:
        description: Destroy the existing stack before applying
        required: false
        type: boolean

concurrency:
  group: vertica-db-apply
  cancel-in-progress: false

jobs:
  apply:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Bootstrap remote backend (idempotent)
        working-directory: infra
        run: |
          bash backend-bootstrap.sh

      - name: Terraform init
        working-directory: infra
        run: terraform init -upgrade

      - name: Import existing resources to avoid duplicates
        working-directory: infra
        run: bash import-if-exists.sh || true

      - name: Optional destroy (recreate)
        if: ${{ inputs.recreate }}
        working-directory: infra
        run: terraform destroy -auto-approve || true

      - name: Validate & Plan (detailed exit code)
        working-directory: infra
        run: |
          terraform validate
          code=0
          terraform plan -detailed-exitcode \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="aws_account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="allowed_cidrs=[\"${{ vars.ALLOWED_CIDR || '0.0.0.0/0' }}\"]" \
            -var="vertica_image=${{ vars.VERTICA_IMAGE || '957650740525.dkr.ecr.ap-south-1.amazonaws.com/vertica-ce:v1.0' }}" \
            || code=$?
          echo plan_exit=$code
          if [ "$code" = "2" ] || [ "$code" = "0" ]; then
            exit 0
          else
            exit "$code"
          fi

      - name: Apply
        working-directory: infra
        run: |
          terraform apply -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="aws_account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="allowed_cidrs=[\"${{ vars.ALLOWED_CIDR || '0.0.0.0/0' }}\"]" \
            -var="vertica_image=${{ vars.VERTICA_IMAGE || '957650740525.dkr.ecr.ap-south-1.amazonaws.com/vertica-ce:v1.0' }}"

      - name: Fetch outputs
        id: out
        working-directory: infra
        run: |
          echo "ip=$(terraform output -raw public_ip)" >> $GITHUB_OUTPUT
          echo "dns=$(terraform output -raw public_dns)" >> $GITHUB_OUTPUT
          echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
          echo "admin_user=$(terraform output -raw additional_admin_username)" >> $GITHUB_OUTPUT
          echo "admin_pass=$(terraform output -raw additional_admin_password)" >> $GITHUB_OUTPUT

      - name: Smoke test via SSM
        env:
          INSTANCE_ID: "${{ steps.out.outputs.instance_id }}"
          ADMIN_USER: "${{ steps.out.outputs.admin_user }}"
          ADMIN_PASSWORD: "${{ steps.out.outputs.admin_pass }}"
        run: |
          set -euo pipefail
          echo "Waiting for instance $INSTANCE_ID to pass EC2 status checks..."
          if ! aws ec2 wait instance-status-ok --instance-ids "$INSTANCE_ID"; then
            echo "Instance did not reach status-ok. Current status:"
            aws ec2 describe-instance-status --instance-ids "$INSTANCE_ID" --include-all-instances || true
            exit 1
          fi

          echo "Waiting for instance $INSTANCE_ID to register with AWS Systems Manager..."
          deadline=$((SECONDS + 900))
          ssm_entry="[]"
          while [ $SECONDS -lt $deadline ]; do
            ssm_entry=$(aws ssm describe-instance-information \
              --query "InstanceInformationList[?InstanceId=='$INSTANCE_ID']" \
              --output json)
            if [ "$ssm_entry" != "[]" ]; then
              break
            fi
            echo "  - Instance has not reported to SSM yet; waiting 10 seconds..."
            sleep 10
          done

          if [ "$ssm_entry" = "[]" ]; then
            echo "Instance failed to register with SSM before timeout. Current inventory entry (if any):"
            aws ssm describe-instance-information --query "InstanceInformationList[?InstanceId=='$INSTANCE_ID']" || true
            exit 1
          fi

          echo "Instance registration detected: $ssm_entry"

          cat >ssm-commands.json <<JSON
          {
            "commands": [
              "set -euo pipefail",
              "python3 -m pip install --quiet vertica-python",
              "ADMIN_USER='$ADMIN_USER' ADMIN_PASSWORD='$ADMIN_PASSWORD' python3 <<'PY'\nimport json\nimport os\nimport socket\nimport subprocess\nimport sys\nimport time\nimport uuid\nfrom urllib.request import urlopen\nfrom typing import Optional\n\nimport vertica_python\n\nDB_NAME = 'VMart'\nDB_PORT = 5433\nDBADMIN_USER = 'dbadmin'\nDBADMIN_PASSWORD = ''\nADMIN_USER = os.environ['ADMIN_USER']\nADMIN_PASSWORD = os.environ['ADMIN_PASSWORD']\n\nif not ADMIN_USER:\n    raise SystemExit('Missing ADMIN_USER value')\nif ADMIN_PASSWORD is None:\n    raise SystemExit('Missing ADMIN_PASSWORD value')\n\nSTEP_SEPARATOR = '=' * 72\n\n\ndef log(message: str) -> None:\n    print(message, flush=True)\n\n\ndef run_command(command: list[str]) -> subprocess.CompletedProcess[str]:\n    log(STEP_SEPARATOR)\n    log(f'$ {" ".join(command)}')\n    result = subprocess.run(command, capture_output=True, text=True)\n    if result.stdout:\n        log(result.stdout.rstrip())\n    if result.stderr:\n        log(f'[stderr] {result.stderr.rstrip()}')\n    if result.returncode != 0:\n        raise SystemExit(f'Command {command!r} failed with exit code {result.returncode}')\n    return result\n\n\ndef fetch_metadata(path: str, timeout: float = 2.0) -> str:\n    url = f'http://169.254.169.254/latest/{path.lstrip("/")}'\n    with urlopen(url, timeout=timeout) as response:\n        return response.read().decode('utf-8').strip()\n\n\ndef wait_for_port(host: str, port: int, timeout: float = 600.0) -> None:\n    deadline = time.time() + timeout\n    last_error: Optional[Exception] = None\n    while time.time() < deadline:\n        try:\n            with socket.create_connection((host, port), timeout=5.0):\n                return\n        except OSError as exc:\n            last_error = exc\n            time.sleep(5)\n    raise SystemExit(f'Port {host}:{port} did not become reachable: {last_error}')\n\n\ndef connect_and_query(label: str, host: str, user: str, password: str) -> None:\n    log(STEP_SEPARATOR)\n    log(f'[{label}] Connecting to Vertica at {host}:{DB_PORT} as {user!r}')\n    config = {\n        'host': host,\n        'port': DB_PORT,\n        'user': user,\n        'password': password,\n        'database': DB_NAME,\n        'autocommit': True,\n    }\n    with vertica_python.connect(**config) as connection:\n        cursor = connection.cursor()\n        cursor.execute('SELECT 1')\n        value = cursor.fetchone()\n        if not value or value[0] != 1:\n            raise SystemExit(f'Unexpected response from SELECT 1 during {label}')\n        log(f'[{label}] SELECT 1 -> {value[0]}')\n\n\ndef main() -> int:\n    log('Beginning in-instance Vertica smoke test with detailed diagnostics')\n    hostname = socket.gethostname()\n    local_ipv4 = fetch_metadata('meta-data/local-ipv4')\n    public_ipv4 = fetch_metadata('meta-data/public-ipv4')\n    log(f'Instance hostname: {hostname}')\n    log(f'Instance local IPv4: {local_ipv4}')\n    log(f'Instance public IPv4: {public_ipv4}')\n\n    wait_for_port('127.0.0.1', DB_PORT, timeout=600.0)\n    log('Verified Vertica port 5433 is accepting TCP connections on localhost')\n\n    run_command(['docker', 'ps', '--format', '{{.Names}}\t{{.Status}}'])\n    image_result = run_command(['docker', 'inspect', '--format', '{{.Config.Image}}', 'vertica_ce'])\n    image_name = image_result.stdout.strip()\n    if image_name:\n        log(f'Vertica container image: {image_name}')\n        run_command(['docker', 'pull', image_name])\n    run_command(['docker', 'inspect', '--format', '{{json .NetworkSettings.Ports}}', 'vertica_ce'])\n\n    connect_and_query('dbadmin@localhost', '127.0.0.1', DBADMIN_USER, DBADMIN_PASSWORD)\n    connect_and_query('bootstrap_admin@localhost', '127.0.0.1', ADMIN_USER, ADMIN_PASSWORD)\n\n    try:\n        connect_and_query('dbadmin@public_ip', public_ipv4, DBADMIN_USER, DBADMIN_PASSWORD)\n    except Exception as exc:\n        log(f'[dbadmin@public_ip] Connection attempt failed: {exc}')\n        raise\n\n    smoke_user = f'smoke_{uuid.uuid4().hex[:8]}'\n    smoke_pass = uuid.uuid4().hex\n    log(STEP_SEPARATOR)\n    log(f'Creating smoke test user {smoke_user!r}')\n    smoke_user_created = False\n    with vertica_python.connect(host='127.0.0.1', port=DB_PORT, user=ADMIN_USER, password=ADMIN_PASSWORD, database=DB_NAME, autocommit=True) as admin_conn:\n        admin_cursor = admin_conn.cursor()\n        admin_cursor.execute(f'CREATE USER "{smoke_user}" IDENTIFIED BY %s', [smoke_pass])\n        admin_cursor.execute(f'GRANT ALL PRIVILEGES ON DATABASE "{DB_NAME}" TO "{smoke_user}"')\n        admin_cursor.execute(f'GRANT USAGE ON SCHEMA PUBLIC TO "{smoke_user}"')\n        admin_cursor.execute(f'GRANT ALL PRIVILEGES ON SCHEMA PUBLIC TO "{smoke_user}"')\n        smoke_user_created = True\n\n    try:\n        connect_and_query('smoke_user@localhost', '127.0.0.1', smoke_user, smoke_pass)\n    finally:\n        if smoke_user_created:\n            log(STEP_SEPARATOR)\n            log(f'Dropping smoke test user {smoke_user!r}')\n            with vertica_python.connect(host='127.0.0.1', port=DB_PORT, user=ADMIN_USER, password=ADMIN_PASSWORD, database=DB_NAME, autocommit=True) as admin_conn:\n                admin_conn.cursor().execute(f'DROP USER "{smoke_user}" CASCADE')\n\n    log(STEP_SEPARATOR)\n    log('All smoke test checks completed successfully')\n    log('SMOKE_TEST_SUCCESS')\n    return 0\n\n\nif __name__ == '__main__':\n    raise SystemExit(main())\nPY"
            ]
          }
          JSON

          command_id=$(aws ssm send-command \
            --document-name AWS-RunShellScript \
            --comment "Vertica smoke test" \
            --instance-ids "$INSTANCE_ID" \
            --parameters file://ssm-commands.json \
            --query 'Command.CommandId' \
            --output text)

          status="InProgress"
          deadline=$((SECONDS + 1200))
          while [ $SECONDS -lt $deadline ]; do
            status=$(aws ssm get-command-invocation \
              --command-id "$command_id" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text \
              2>/dev/null || echo "InProgress")
            status=${status:-InProgress}

            case "$status" in
              Success)
                break
                ;;
              Failed|Cancelled|TimedOut|Cancelling)
                aws ssm get-command-invocation \
                  --command-id "$command_id" \
                  --instance-id "$INSTANCE_ID"
                exit 1
                ;;
            esac

            sleep 15
          done

          if [ "$status" != "Success" ]; then
            echo "SSM command did not complete before timeout (status: $status)."
            aws ssm get-command-invocation \
              --command-id "$command_id" \
              --instance-id "$INSTANCE_ID" || true
            exit 1
          fi

          output=$(aws ssm get-command-invocation \
            --command-id "$command_id" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' \
            --output text)

          stderr_output=$(aws ssm get-command-invocation \
            --command-id "$command_id" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardErrorContent' \
            --output text)

          echo "===== SSM command standard output ====="
          printf '%s\n' "$output"
          echo "===== End of standard output ====="

          if [ -n "$stderr_output" ]; then
            echo "===== SSM command standard error ====="
            printf '%s\n' "$stderr_output"
            echo "===== End of standard error ====="
          fi

          if ! printf '%s\n' "$output" | tail -n 1 | grep -q 'SMOKE_TEST_SUCCESS'; then
            echo "Smoke test did not report success" >&2
            exit 1
          fi

      - name: Job summary
        run: |
          echo "### Vertica is up" >> $GITHUB_STEP_SUMMARY
          echo "- Host: \`${{ steps.out.outputs.ip }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Port: \`5433\` User: \`${{ steps.out.outputs.admin_user }}\` Password: \`${{ steps.out.outputs.admin_pass }}\` DB: \`VMart\`" >> $GITHUB_STEP_SUMMARY
          echo "- Bootstrap user \`dbadmin\` remains available with an empty password" >> $GITHUB_STEP_SUMMARY
