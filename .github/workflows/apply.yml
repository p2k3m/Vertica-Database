name: Deploy Vertica DB (apply)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      recreate:
        description: Destroy the existing stack before applying
        required: false
        type: boolean

concurrency:
  group: vertica-db-apply
  cancel-in-progress: false

jobs:
  apply:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Bootstrap remote backend (idempotent)
        working-directory: infra
        run: |
          bash backend-bootstrap.sh

      - name: Terraform init
        working-directory: infra
        run: terraform init -upgrade

      - name: Import existing resources to avoid duplicates
        working-directory: infra
        run: bash import-if-exists.sh || true

      - name: Optional destroy (recreate)
        if: ${{ inputs.recreate }}
        working-directory: infra
        run: terraform destroy -auto-approve || true

      - name: Validate & Plan (detailed exit code)
        working-directory: infra
        run: |
          terraform validate
          code=0
          terraform plan -detailed-exitcode \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="aws_account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="allowed_cidrs=[\"${{ vars.ALLOWED_CIDR || '0.0.0.0/0' }}\"]" \
            -var="vertica_image=${{ vars.VERTICA_IMAGE || '957650740525.dkr.ecr.ap-south-1.amazonaws.com/vertica-ce:v1.0' }}" \
            || code=$?
          echo plan_exit=$code
          if [ "$code" = "2" ] || [ "$code" = "0" ]; then
            exit 0
          else
            exit "$code"
          fi

      - name: Apply
        working-directory: infra
        run: |
          terraform apply -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="aws_account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="allowed_cidrs=[\"${{ vars.ALLOWED_CIDR || '0.0.0.0/0' }}\"]" \
            -var="vertica_image=${{ vars.VERTICA_IMAGE || '957650740525.dkr.ecr.ap-south-1.amazonaws.com/vertica-ce:v1.0' }}"

      - name: Fetch outputs
        id: out
        working-directory: infra
        run: |
          echo "ip=$(terraform output -raw public_ip)" >> $GITHUB_OUTPUT
          echo "dns=$(terraform output -raw public_dns)" >> $GITHUB_OUTPUT
          echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT

      - name: Smoke test via SSM
        env:
          INSTANCE_ID: "${{ steps.out.outputs.instance_id }}"
        run: |
          set -euo pipefail
          echo "Waiting for instance $INSTANCE_ID to pass EC2 status checks..."
          if ! aws ec2 wait instance-status-ok --instance-ids "$INSTANCE_ID"; then
            echo "Instance did not reach status-ok. Current status:"
            aws ec2 describe-instance-status --instance-ids "$INSTANCE_ID" --include-all-instances || true
            exit 1
          fi

          echo "Waiting for instance $INSTANCE_ID to register with AWS Systems Manager..."
          if ! aws ssm wait instance-online --instance-ids "$INSTANCE_ID"; then
            echo "Instance failed to register with SSM. Current inventory entry (if any):"
            aws ssm describe-instance-information --query "InstanceInformationList[?InstanceId=='$INSTANCE_ID']" || true
            exit 1
          fi

          cat >ssm-commands.json <<'JSON'
          {
            "commands": [
              "python3 -m pip install --quiet vertica-python",
              "python3 -c 'import vertica_python; conn=vertica_python.connect(host=\"127.0.0.1\", port=5433, user=\"dbadmin\", password=\"\", database=\"VMart\"); cur=conn.cursor(); cur.execute(\"SELECT 1\"); print(cur.fetchone()[0])'"
            ]
          }
          JSON

          command_id=$(aws ssm send-command \
            --document-name AWS-RunShellScript \
            --comment "Vertica smoke test" \
            --instance-ids "$INSTANCE_ID" \
            --parameters file://ssm-commands.json \
            --query 'Command.CommandId' \
            --output text)

          aws ssm wait command-executed --command-id "$command_id" --instance-id "$INSTANCE_ID"

          status=$(aws ssm get-command-invocation \
            --command-id "$command_id" \
            --instance-id "$INSTANCE_ID" \
            --query 'Status' \
            --output text)

          if [ "$status" != "Success" ]; then
            aws ssm get-command-invocation \
              --command-id "$command_id" \
              --instance-id "$INSTANCE_ID"
            exit 1
          fi

          output=$(aws ssm get-command-invocation \
            --command-id "$command_id" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' \
            --output text)

          echo "$output"

          last_line=$(printf '%s\n' "$output" | tail -n 1)
          if [ "$last_line" != "1" ]; then
            echo "Unexpected Vertica response" >&2
            exit 1
          fi

      - name: Job summary
        run: |
          echo "### Vertica is up" >> $GITHUB_STEP_SUMMARY
          echo "- Host: \`${{ steps.out.outputs.ip }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Port: \`5433\` User: \`dbadmin\` Password: \`(empty)\` DB: \`VMart\`" >> $GITHUB_STEP_SUMMARY
