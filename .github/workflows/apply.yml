name: Deploy Vertica DB (apply)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      recreate:
        description: Destroy the existing stack before applying
        required: false
        type: boolean

concurrency:
  group: vertica-db-apply
  cancel-in-progress: false

jobs:
  apply:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Bootstrap remote backend (idempotent)
        working-directory: infra
        run: |
          bash backend-bootstrap.sh

      - name: Terraform init
        working-directory: infra
        run: terraform init -upgrade

      - name: Import existing resources to avoid duplicates
        working-directory: infra
        run: bash import-if-exists.sh || true

      - name: Optional destroy (recreate)
        if: ${{ inputs.recreate }}
        working-directory: infra
        run: terraform destroy -auto-approve || true

      - name: Validate & Plan (detailed exit code)
        working-directory: infra
        run: |
          terraform validate
          code=0
          terraform plan -detailed-exitcode \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="aws_account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="allowed_cidrs=[\"${{ vars.ALLOWED_CIDR || '0.0.0.0/0' }}\"]" \
            -var="vertica_image=${{ vars.VERTICA_IMAGE || '957650740525.dkr.ecr.ap-south-1.amazonaws.com/vertica-ce:v1.0' }}" \
            || code=$?
          echo plan_exit=$code
          if [ "$code" = "2" ] || [ "$code" = "0" ]; then
            exit 0
          else
            exit "$code"
          fi

      - name: Apply
        working-directory: infra
        run: |
          terraform apply -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="aws_account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="allowed_cidrs=[\"${{ vars.ALLOWED_CIDR || '0.0.0.0/0' }}\"]" \
            -var="vertica_image=${{ vars.VERTICA_IMAGE || '957650740525.dkr.ecr.ap-south-1.amazonaws.com/vertica-ce:v1.0' }}"

      - name: Fetch outputs
        id: out
        working-directory: infra
        run: |
          echo "ip=$(terraform output -raw public_ip)" >> $GITHUB_OUTPUT
          echo "dns=$(terraform output -raw public_dns)" >> $GITHUB_OUTPUT
          echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT

      - name: Smoke test via SSM
        env:
          INSTANCE_ID: "${{ steps.out.outputs.instance_id }}"
        run: |
          set -euo pipefail
          echo "Waiting for instance $INSTANCE_ID to pass EC2 status checks..."
          if ! aws ec2 wait instance-status-ok --instance-ids "$INSTANCE_ID"; then
            echo "Instance did not reach status-ok. Current status:"
            aws ec2 describe-instance-status --instance-ids "$INSTANCE_ID" --include-all-instances || true
            exit 1
          fi

          echo "Waiting for instance $INSTANCE_ID to register with AWS Systems Manager..."
          deadline=$((SECONDS + 600))
          ssm_entry="[]"
          while [ $SECONDS -lt $deadline ]; do
            ssm_entry=$(aws ssm describe-instance-information \
              --query "InstanceInformationList[?InstanceId=='$INSTANCE_ID']" \
              --output json)
            if [ "$ssm_entry" != "[]" ]; then
              break
            fi
            sleep 10
          done

          if [ "$ssm_entry" = "[]" ]; then
            echo "Instance failed to register with SSM before timeout. Current inventory entry (if any):"
            aws ssm describe-instance-information --query "InstanceInformationList[?InstanceId=='$INSTANCE_ID']" || true
            exit 1
          fi

          cat >ssm-commands.json <<'JSON'
          {
            "commands": [
              "python3 -m pip install --quiet vertica-python",
              "python3 <<'PY'\nimport socket\nimport time\nimport vertica_python\n\nHOST = '127.0.0.1'\nPORT = 5433\nDEADLINE = time.time() + 600\nwhile time.time() < DEADLINE:\n    with socket.socket() as sock:\n        sock.settimeout(5)\n        try:\n            sock.connect((HOST, PORT))\n        except OSError:\n            time.sleep(5)\n        else:\n            break\nelse:\n    raise SystemExit('Vertica port never became reachable')\n\nfor attempt in range(12):\n    try:\n        with vertica_python.connect(host=HOST, port=PORT, user='dbadmin', password='', database='VMart') as conn:\n            cur = conn.cursor()\n            cur.execute('SELECT 1')\n            value = cur.fetchone()\n            if not value:\n                raise SystemExit('Empty response from SELECT 1')\n            print(value[0])\n            break\n    except Exception:\n        if attempt == 11:\n            raise\n        time.sleep(5)\nPY"
            ]
          }
          JSON

          command_id=$(aws ssm send-command \
            --document-name AWS-RunShellScript \
            --comment "Vertica smoke test" \
            --instance-ids "$INSTANCE_ID" \
            --parameters file://ssm-commands.json \
            --query 'Command.CommandId' \
            --output text)

          status="InProgress"
          deadline=$((SECONDS + 1200))
          while [ $SECONDS -lt $deadline ]; do
            status=$(aws ssm get-command-invocation \
              --command-id "$command_id" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text \
              2>/dev/null || echo "InProgress")
            status=${status:-InProgress}

            case "$status" in
              Success)
                break
                ;;
              Failed|Cancelled|TimedOut|Cancelling)
                aws ssm get-command-invocation \
                  --command-id "$command_id" \
                  --instance-id "$INSTANCE_ID"
                exit 1
                ;;
            esac

            sleep 15
          done

          if [ "$status" != "Success" ]; then
            echo "SSM command did not complete before timeout (status: $status)."
            aws ssm get-command-invocation \
              --command-id "$command_id" \
              --instance-id "$INSTANCE_ID" || true
            exit 1
          fi

          output=$(aws ssm get-command-invocation \
            --command-id "$command_id" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' \
            --output text)

          echo "$output"

          last_line=$(printf '%s\n' "$output" | tail -n 1)
          if [ "$last_line" != "1" ]; then
            echo "Unexpected Vertica response" >&2
            exit 1
          fi

      - name: Job summary
        run: |
          echo "### Vertica is up" >> $GITHUB_STEP_SUMMARY
          echo "- Host: \`${{ steps.out.outputs.ip }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Port: \`5433\` User: \`dbadmin\` Password: \`(empty)\` DB: \`VMart\`" >> $GITHUB_STEP_SUMMARY
